{
  "name": "B+ Tree",
  "wiki": {
    "concept": "1. Definition",
    "conceptDesc": "A B+ Tree is an N-ary tree variation where **all data records are stored in the leaf nodes**. Internal nodes serve only as an index for navigation, containing routing keys without actual data.",
    "properties": "2. Key Properties (Order m)",
    "propertiesDesc": "- **Data at Leaves Only**: All values reside exclusively in leaf nodes; internal nodes only guide search\n- **Linked Leaf Layer**: Leaf nodes form a **doubly-linked list** via `next` pointers for efficient sequential access\n- **Redundant Keys**: Keys in internal nodes are **copies** of keys in leaves (for routing)\n- **Max Children**: Every node has at most `m` children\n- **Min Keys**: Non-root nodes have at least `⌈m/2⌉-1` keys\n- **Balanced**: All leaves at the same level",
    "insertion": "3. Insertion",
    "insertionDesc": "**Bottom-up approach (always insert into leaves):**\n\n1. **Find Target Leaf**: Navigate down using internal routing keys\n2. **Insert into Leaf**: Add key to leaf (maintaining sort order)\n3. **Handle Leaf Overflow** (if keys = m):\n   - Split leaf into left and right\n   - **Promote first key of right leaf** to parent\n   - **CRITICAL**: Keep the promoted key in the right leaf (unlike B-Tree)\n   - Update leaf links: `left.next = right`\n4. **Handle Internal Overflow** (if parent overflows):\n   - Split internal node\n   - Promote **middle key** to parent\n   - Remove promoted key from internal node\n5. If root splits → tree height increases by 1\n\n**Key Difference from B-Tree**: Leaf split keeps promoted key; internal split removes it.",
    "deletion": "4. Deletion",
    "deletionDesc": "**Always delete from leaves:**\n\n**Phase 1: Locate and Delete**\n- Navigate to leaf containing the key\n- Remove key from leaf\n- Update internal routing keys if necessary\n\n**Phase 2: Handle Underflow** (if keys < ⌈m/2⌉-1)\n\n**Case 1 - Borrow from Sibling** (if sibling has > ⌈m/2⌉-1 keys):\n- **Leaf Borrow**: Transfer key from sibling, update parent routing key\n- **Internal Borrow**: Rotate through parent\n\n**Case 2 - Merge with Sibling** (if both at minimum):\n- **Leaf Merge**: Combine leaves, remove parent separator, update links\n- **Internal Merge**: Combine with parent key, recursively fix parent\n\n**Case 3 - Update Routing Keys**:\n- If deleted key appears in internal nodes, replace with successor\n\n**Priority**: Try borrowing before merging to minimize structural changes.",
    "applications": "5. Applications",
    "applicationsDesc": "**Why B+ Trees dominate databases and file systems:**\n\n- **Database Indexes**: MySQL InnoDB, PostgreSQL primary indexes\n- **File Systems**: NTFS, XFS, ext4 directory structures\n- **Range Queries**: Linked leaves enable efficient `SELECT * WHERE key BETWEEN a AND b`\n- **Sequential Access**: Leaf chain allows fast full table scans\n- **Disk I/O Optimization**: Internal nodes packed with more keys (no data) → fewer disk reads\n\n**Advantages over B-Tree:**\n- Faster range queries (no tree traversal needed)\n- Better cache locality for sequential scans\n- Higher fanout (more keys per internal node)",
    "complexity": "6. Time Complexity",
    "complexityDesc": "- **Search**: O(log n) - navigate from root to leaf\n- **Insert**: O(log n) - search + potential splits up to root\n- **Delete**: O(log n) - search + potential merges up to root\n- **Range Query**: O(log n + k) - find start + scan k leaves\n- **Sequential Scan**: O(n) - traverse leaf chain\n- **Space**: O(n)\n\nwhere n is the number of keys, k is the range size.\n\n**Disk I/O**: Typically 3-4 disk reads for trees with millions of records (order 100-200)."
  }
}
