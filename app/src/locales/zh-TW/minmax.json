{
  "name": "Min-Max Heap",
  "wiki": {
    "concept": "1. 定義",
    "conceptDesc": "Min-Max Heap 是一種完全二元樹，結合了最小堆積和最大堆積的特性，能同時快速存取最大值和最小值。",
    "levels": "2. 最小/最大層",
    "levelsDesc": "層級交替為最小層和最大層。偶數層 (0, 2, 4...) 為最小層，節點值小於所有後代。奇數層 (1, 3, 5...) 為最大層，節點值大於所有後代。",
    "insert": "3. 插入操作 (Push Up)",
    "insertDesc": "將新元素 `x` 放入陣列末尾 `i`，然後執行上浮：\n1. 與父節點 `p` 比較。\n2. 若 `i` 位於 **Min 層**：\n   - 若 `x > p`，則 `x` 違反了 Min 性質但可能屬於 Max 層。將 `x` 與 `p` 交換，然後從 `p` 執行 `PushUpMax`。\n   - 否則，從 `i` 執行 `PushUpMin`（檢查祖父節點）。\n3. 若位於 **Max 層**，邏輯對稱。",
    "extract": "4. 取出極值 (Push Down)",
    "extractDesc": "**取出最小值：** 最小值永遠在根節點 (index 0)。移除它，將末尾元素移至根，然後執行 `PushDownMin`。\n\n**PushDownMin 演算法：**\n1. 在所有孩子與孫子中找出最小者 `m`。\n2. 若 `m` 是孫子節點：\n   - 若 `heap[m] < heap[i]`，交換兩者。\n   - 交換後，若 `heap[m] > heap[parent(m)]`，則交換 `m` 與其父節點（修復 Max 層性質）。\n   - 從 `m` 繼續遞迴執行 `PushDownMin`。\n3. 若 `m` 是孩子節點，僅需交換一次即可。"
  }
}
