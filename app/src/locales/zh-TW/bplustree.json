{
  "name": "B+ 樹",
  "wiki": {
    "concept": "1. 定義",
    "conceptDesc": "B+ Tree 是一種 B-Tree 的變體，**所有資料紀錄都儲存在葉子節點**。內部節點僅作為索引導航，包含路由鍵值但不含實際資料。",
    "properties": "2. 核心性質 (階數 m)",
    "propertiesDesc": "- **葉子專責儲存**: 所有值僅存於葉節點；內部節點只負責導航搜尋\n- **葉層鏈結**: 葉節點透過 `next` 指標形成**雙向鏈結串列**，支援高效循序存取\n- **冗餘鍵值**: 內部節點的鍵值是葉節點的**副本**（用於路由）\n- **最大子節點數**: 每個節點最多 `m` 個子節點\n- **最小鍵值數**: 非根節點至少 `⌈m/2⌉-1` 個鍵值\n- **平衡性**: 所有葉子在同一層",
    "insertion": "3. 插入操作",
    "insertionDesc": "**由下而上策略（總是插入到葉節點）：**\n\n1. **找到目標葉節點**: 使用內部路由鍵值向下導航\n2. **插入至葉節點**: 將鍵值加入葉節點（保持排序）\n3. **處理葉節點溢位** (若鍵值數 = m)：\n   - 分裂為左右兩葉節點\n   - **提升右葉第一個鍵值**到父節點\n   - **關鍵**：提升的鍵值**保留在右葉中**（不同於 B-Tree）\n   - 更新鏈結：`left.next = right`\n4. **處理內部節點溢位** (若父節點也溢位)：\n   - 分裂內部節點\n   - 提升**中間鍵值**到父節點\n   - 從內部節點**移除**提升的鍵值\n5. 若根節點分裂 → 樹高度加 1\n\n**與 B-Tree 的關鍵差異**：葉節點分裂保留提升鍵；內部節點分裂移除提升鍵。",
    "deletion": "4. 刪除操作",
    "deletionDesc": "**總是從葉節點刪除：**\n\n**階段 1：定位並刪除**\n- 導航到包含鍵值的葉節點\n- 從葉節點移除鍵值\n- 必要時更新內部路由鍵值\n\n**階段 2：處理下溢** (若鍵值數 < ⌈m/2⌉-1)\n\n**情況 1 - 向兄弟借用** (若兄弟有 > ⌈m/2⌉-1 個鍵值)：\n- **葉節點借用**：從兄弟轉移鍵值，更新父節點路由鍵\n- **內部節點借用**：透過父節點旋轉\n\n**情況 2 - 與兄弟合併** (若兩者都在最小值)：\n- **葉節點合併**：合併兩葉節點，移除父節點分隔鍵，更新鏈結\n- **內部節點合併**：與父節點鍵值合併，遞迴修復父節點\n\n**情況 3 - 更新路由鍵值**：\n- 若刪除的鍵值出現在內部節點，以後繼鍵值替換\n\n**優先順序**：先嘗試借用，再考慮合併，以減少結構變動。",
    "applications": "5. 應用場景",
    "applicationsDesc": "**為何 B+ Tree 主宰資料庫與檔案系統：**\n\n- **資料庫索引**: MySQL InnoDB、PostgreSQL 主索引\n- **檔案系統**: NTFS、XFS、ext4 目錄結構\n- **範圍查詢**: 葉鏈結支援高效 `SELECT * WHERE key BETWEEN a AND b`\n- **循序存取**: 葉鏈串列允許快速全表掃描\n- **磁碟 I/O 最佳化**: 內部節點塞滿更多鍵值（無資料）→ 減少磁碟讀取\n\n**相較於 B-Tree 的優勢：**\n- 範圍查詢更快（無需樹遍歷）\n- 循序掃描有更好的快取局部性\n- 更高的分支因子（每個內部節點更多鍵值）",
    "complexity": "6. 時間複雜度",
    "complexityDesc": "- **搜尋**: O(log n) - 從根導航到葉\n- **插入**: O(log n) - 搜尋 + 可能分裂至根\n- **刪除**: O(log n) - 搜尋 + 可能合併至根\n- **範圍查詢**: O(log n + k) - 找起點 + 掃描 k 個葉節點\n- **循序掃描**: O(n) - 遍歷葉鏈結\n- **空間**: O(n)\n\n其中 n 為鍵值總數，k 為範圍大小。\n\n**磁碟 I/O**：對於百萬筆紀錄的樹（階數 100-200），通常只需 3-4 次磁碟讀取。"
  }
}

