{
  "title": "紅黑樹",
  "description": "一種基於顏色平衡的自平衡二元搜尋樹",
  "wiki": {
    "concept": "1. 什麼是紅黑樹？",
    "conceptDesc": "**紅黑樹（Red-Black Tree）** 是一種自平衡二元搜尋樹，每個節點包含一個額外的顏色位元（紅色或黑色）。這些顏色確保樹在插入和刪除時保持近似平衡，保證 O(log n) 的操作效能。\n\n主要特性：\n- 每個節點非**紅**即**黑**\n- 比 AVL 樹的平衡更簡單（旋轉次數更少）\n- 廣泛應用於標準函式庫（如 C++ STL map/set、Java TreeMap）",
    
    "properties": "2. 紅黑樹性質",
    "propertiesDesc": "有效的紅黑樹必須滿足這五個性質：\n\n1. **根性質**：根節點永遠是**黑色**\n2. **外部性質**：所有 NULL 葉節點（外部節點）視為**黑色**\n3. **紅色性質**：如果一個節點是**紅色**，其兩個子節點必須是**黑色**（不能有兩個連續的紅色節點）\n4. **黑高性質**：從任一節點到其所有後代 NULL 節點的路徑上，包含相同數量的**黑色**節點\n5. **二元搜尋樹性質**：對於任意節點，左子樹所有值 < 節點值 < 右子樹所有值\n\n這些性質確保樹的高度最多為 **2 log(n+1)**，保證平衡的操作效能。",
    
    "insertion": "3. 插入演算法",
    "insertionDesc": "以**紅色**節點進行標準 BST 插入，然後修正違反的性質：\n\n**情況 1：新節點是根**\n- 塗成**黑色**\n\n**情況 2：父節點是黑色**\n- 無違反，完成\n\n**情況 3：父節點和叔叔節點都是紅色**\n- 重新著色：父節點 → **黑色**、叔叔節點 → **黑色**、祖父節點 → **紅色**\n- 從祖父節點繼續修正\n\n**情況 4：父節點紅色、叔叔節點黑色（三角形）**\n- 如果節點是**右子節點**且父節點是**左子節點**（或相反）\n- 對父節點旋轉，轉換為情況 5\n\n**情況 5：父節點紅色、叔叔節點黑色（直線）**\n- 重新著色：父節點 → **黑色**、祖父節點 → **紅色**\n- 對祖父節點旋轉\n\n每次插入**最多需要 2 次旋轉**（比 AVL 的潛在旋轉鏈簡單）。",
    
    "deletion": "4. 刪除演算法",
    "deletionDesc": "刪除比插入更複雜，涉及節點替換和修復：\n\n**步驟 1：標準 BST 刪除**\n- 若節點有 **0 或 1 個子節點**：用子節點替換\n- 若節點有 **2 個子節點**：用中序前驅/後繼替換，然後刪除該節點\n\n**步驟 2：修復違反（如果被刪除的節點是黑色）**\n\n**情況 1：兄弟是紅色**\n- 重新著色：兄弟 → **黑色**、父節點 → **紅色**\n- 對父節點旋轉，轉換為情況 2/3/4\n\n**情況 2：兄弟是黑色，兩個侄子節點都是黑色**\n- 重新著色：兄弟 → **紅色**\n- 問題向上傳遞至父節點\n\n**情況 3：兄弟是黑色，近侄子是紅色，遠侄子是黑色**\n- 重新著色：近侄子 → **黑色**、兄弟 → **紅色**\n- 對兄弟旋轉，轉換為情況 4\n\n**情況 4：兄弟是黑色，遠侄子是紅色**\n- 複製父節點的顏色到兄弟\n- 重新著色：父節點 → **黑色**、遠侄子 → **黑色**\n- 對父節點旋轉，完成\n\n每次刪除**最多需要 3 次旋轉**。",
    
    "complexity": "5. 時間複雜度",
    "complexityDesc": "| 操作 | 平均 | 最差 |\n|------|------|------|\n| 搜尋 | O(log n) | O(log n) |\n| 插入 | O(log n) | O(log n) |\n| 刪除 | O(log n) | O(log n) |\n\n**空間複雜度**：O(n) 儲存 n 個節點\n\n**相較於 AVL 樹的優勢**：\n- 插入/刪除時旋轉次數更少（更新更快）\n- 實作更簡單\n- 適合插入/刪除頻繁的場景\n\n**與 AVL 比較**：\n- AVL 更嚴格平衡（適合搜尋為主的場景）\n- 紅黑樹適合混合操作（實務資料庫應用）"
  }
}
